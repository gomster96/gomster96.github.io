{"componentChunkName":"component---src-templates-blog-post-js","path":"/PS/다익스트라/1504/","result":{"data":{"site":{"siteMetadata":{"title":"Gomster","author":"Gomster","siteUrl":"https://gomster96.github.io","comment":{"disqusShortName":"","utterances":"gomster96/gomster96.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"52ddb767-4f3b-532c-b942-fc600e640121","excerpt":"문제 백준 문제 링크 : https://www.acmicpc.net/problem/1504 풀이전략 최단거리이기 때문에 다익스트라 알고리즘을 사용한다. 하지만 문제에서 주어지는 2가지 정점을 지나야 한다는 요구사항이 있다. 반드시 지나야하는 두 정점을 v1, v2 라고 하면 경로는 다음과같이 구할 수 있다. 1 -> v1 -> v2 -> N 1 -> v2 -> v1 -> N 따라서 1번 경로를 해결하려면 다익스트라 알고리즘을 1-> v1으로 한번, v1-> v2로 한번, v2 -> N…","html":"<h1 id=\"문제\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C\" aria-label=\"문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제</h1>\n<p>백준 문제 링크 : <a href=\"https://www.acmicpc.net/problem/1504\">https://www.acmicpc.net/problem/1504</a></p>\n<h1 id=\"풀이전략\" style=\"position:relative;\"><a href=\"#%ED%92%80%EC%9D%B4%EC%A0%84%EB%9E%B5\" aria-label=\"풀이전략 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>풀이전략</h1>\n<p>최단거리이기 때문에 다익스트라 알고리즘을 사용한다. 하지만 문제에서 주어지는 2가지 정점을 지나야 한다는 요구사항이 있다. 반드시 지나야하는 두 정점을 v1, v2 라고 하면 경로는 다음과같이 구할 수 있다.</p>\n<ol>\n<li>1 -> v1 -> v2 -> N</li>\n<li>1 -> v2 -> v1 -> N</li>\n</ol>\n<p>따라서 1번 경로를 해결하려면 다익스트라 알고리즘을 1-> v1으로 한번, v1-> v2로 한번, v2 -> N 으로 한번 총 3번 돌리면 된다. 2번경로도 마찬가지이다.</p>\n<h1 id=\"코드\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C\" aria-label=\"코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드</h1>\n<p>package backjoon.P1504;</p>\n<p>import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;</p>\n<p>public class Main {</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">static class Node{\n    int v, dis;\n\n    public Node(int v, int dis) {\n        this.v = v;\n        this.dis = dis;\n    }\n}\n\nstatic int[] distance;\nstatic int INF = 200000000;\nstatic  ArrayList&lt;ArrayList&lt;Node>> graph;\npublic static void main(String[] args) throws Exception {\n    System.setIn(new FileInputStream(\"src/backjoon/input.txt\"));\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n    StringTokenizer st;\n    st = new StringTokenizer(br.readLine());\n    int N = Integer.parseInt(st.nextToken());\n    int E = Integer.parseInt(st.nextToken());\n\n    graph = new ArrayList&lt;>();\n\n    for(int i=0; i&lt;=N; i++){\n        graph.add(new ArrayList&lt;>());\n    }\n\n    for(int i=0; i&lt;E; i++){\n        st = new StringTokenizer(br.readLine());\n        int a = Integer.parseInt(st.nextToken());\n        int b = Integer.parseInt(st.nextToken());\n        int c = Integer.parseInt(st.nextToken());\n\n        graph.get(a).add(new Node(b, c));\n        graph.get(b).add(new Node(a, c));\n\n    }\n\n\n\n    st = new StringTokenizer(br.readLine());\n    int v1 = Integer.parseInt(st.nextToken());\n    int v2 = Integer.parseInt(st.nextToken());\n\n    distance = new int[N+1];\n\n    // 1 -> v1 -> v2 -> N\n    int res1 = 0;\n    res1 += dijkstra(1, v1);\n    res1 += dijkstra(v1, v2);\n    res1 += dijkstra(v2, N);\n\n\n\n    // 1 -> v2 -> v1 -> N\n    int res2 = 0;\n    res2 += dijkstra(1, v2);\n    res2 += dijkstra(v2, v1);\n    res2 += dijkstra(v1, N);\n    int answer = (res1 >= INF &amp;&amp; res2 >= INF)? -1 : Math.min(res1, res2);\n    System.out.println(answer);\n}\n\n\npublic static int dijkstra(int start, int end){\n    PriorityQueue&lt;Node> pq = new PriorityQueue&lt;>((n1, n2) -> {\n        return n1.dis - n2.dis;\n    });\n\n    Arrays.fill(distance, INF);\n\n    distance[start] = 0;\n    pq.add(new Node(start, 0));\n\n    while(!pq.isEmpty()){\n        Node cur = pq.poll();\n\n        if(distance[cur.v] &lt; cur.dis) continue;\n\n        for(Node node : graph.get(cur.v)){\n\n            if(distance[cur.v] + node.dis &lt; distance[node.v] ){\n\n                distance[node.v] = distance[cur.v] + node.dis;\n                pq.add(new Node(node.v, distance[cur.v] + node.dis));\n            }\n        }\n\n    }\n\n    return distance[end];\n}</code></pre></div>\n<p>}</p>\n<h1 id=\"회고\" style=\"position:relative;\"><a href=\"#%ED%9A%8C%EA%B3%A0\" aria-label=\"회고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>회고</h1>\n<ul>\n<li>반드시 지나야 하는 두 정점을 정해주었기 때문에 더 편하게 풀었다. 처음에 문제를 접근할 때 반드시 지나야 하는 두 정점을 주어지는줄 몰랐다. 문제를 상세히 읽는게 중요하다.</li>\n</ul>","frontmatter":{"title":"백준 1504번 JAVA : 특정한 최단 경로","date":"September 01, 2022"}}},"pageContext":{"slug":"/PS/다익스트라/1504/","previous":{"fields":{"slug":"/PS/구현/16926/"},"frontmatter":{"title":"백준 16926번 JAVA : 배열 돌리기 1"}},"next":{"fields":{"slug":"/PS/구현/20207/"},"frontmatter":{"title":"백준 20207번 JAVA : 달력"}}}}}