{"componentChunkName":"component---src-templates-blog-post-js","path":"/Spring/다형성과SOLID5원칙/","result":{"data":{"site":{"siteMetadata":{"title":"Gomster","author":"Gomster","siteUrl":"https://gomster96.github.io","comment":{"disqusShortName":"","utterances":"gomster96/gomster96.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"216de3db-f4a9-57bf-b68b-82bdd4d6ecac","excerpt":"…","html":"<h1 id=\"다형성이란\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%B4%EB%9E%80\" aria-label=\"다형성이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성이란?</h1>\n<div class=\"gatsby-highlight\" data-language=\"md\"><pre class=\"language-md\"><code class=\"language-md\">다형성이란 프로그램 언어 각 요소들(상수, 변수, 식, 객체, 메소드 등)이 다양한 자료 형(type)에 속하는 것이 허가되는 성질을 가르킨다.</code></pre></div>\n<p>즉 다형성이란 하나의 타입에 여러 객체를 대입할 수 있는 성질이라고 이해하면 된다. 따라서 다형성을 활용하면 기능을 확장하거나, 객체를 변경해야할 때 타입의 변경 없이 객체 주입만으로 수정이 일어나게 할 수 있다.</p>\n<ul>\n<li>인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.</li>\n<li>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.</li>\n</ul>\n<h1 id=\"역활과-구현을-분리\" style=\"position:relative;\"><a href=\"#%EC%97%AD%ED%99%9C%EA%B3%BC-%EA%B5%AC%ED%98%84%EC%9D%84-%EB%B6%84%EB%A6%AC\" aria-label=\"역활과 구현을 분리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역활과 구현을 분리</h1>\n<p>다형성을 효과적으로 활용하기 위해서, 역할과 구현을 확실하게 분리하는 것이 필요하다.</p>\n<p>여기서 역할은 인터페이스이고, 구현은 해당 인터페이스를 구현한 클래스 또는 객체 인스턴스이다.</p>\n<ul>\n<li>자동차를 예를 들면, 자동차의 기능 자체는 역할(interface)이 된다. 이후 자동차의 종류 아반떼, K5, 제네시스 등 자동차의 기능이라는 역할(interface)를 구현한 객체 들이 구현 부분이 된다.</li>\n</ul>\n<h1 id=\"다형성과-스프링\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1%EA%B3%BC-%EC%8A%A4%ED%94%84%EB%A7%81\" aria-label=\"다형성과 스프링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성과 스프링</h1>\n<p>스프링은 다형성을 극대화해서 이용할 수 있게 도와준다. 스프링에서 제공하는 제어의 역전(IoC), 의존관계 주입(DI)는 다형성을 활용해서 역활과 구현을 편리하게 다룰 수 있도록 지원한다.</p>\n<h1 id=\"좋은-객체-지향-설계의-5가지-원칙solid\" style=\"position:relative;\"><a href=\"#%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99solid\" aria-label=\"좋은 객체 지향 설계의 5가지 원칙solid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>좋은 객체 지향 설계의 5가지 원칙(SOLID)</h1>\n<p>SOLID 5원칙은 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리한 것이다.</p>\n<ul>\n<li>SRP : 단일 책임 원칙 (Single Responsibility Principle)</li>\n<li>OCP : 개방-폐쇠 원칙 (Open/Closed Principle)</li>\n<li>LSP : 리스코프 치환 원칙 (Liskov substitution Principle)</li>\n<li>ISP : 인터페이스 분리 원칙 (Interface Segregation Principle)</li>\n<li>DIP : 의존관계 역전 원칙 (Dependency Inversion Principle)</li>\n</ul>\n<h2 id=\"srp-단일-책임-원칙-single-responsibility-principle\" style=\"position:relative;\"><a href=\"#srp-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99-single-responsibility-principle\" aria-label=\"srp 단일 책임 원칙 single responsibility principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>SRP 단일 책임 원칙 (Single Responsibility Principle)</h2>\n<ul>\n<li>한 클래스는 하나의 책임만 가져야 한다.</li>\n<li>중요한 기준은 변경으로, 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.</li>\n</ul>\n<h2 id=\"ocp-개방-폐쇠-원칙-openclosed-principle\" style=\"position:relative;\"><a href=\"#ocp-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%A0-%EC%9B%90%EC%B9%99-openclosed-principle\" aria-label=\"ocp 개방 폐쇠 원칙 openclosed principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OCP 개방-폐쇠 원칙 (Open/closed Principle)</h2>\n<ul>\n<li>소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.</li>\n<li>다형성을 활용해보아야한다.</li>\n</ul>\n<p>하지만 다음과 같은 예시를 보면, 분명 다형성을 이용하여 구현체를 바꿨지만, 클라이언트 코드를 변경하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span>  <span class=\"token class-name\">MemberService</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// private MemberRepository memberRepository = new MemoryMemberRepository();</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">MemberRepository</span> memberRepository <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JdbcMemberRepository</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>따라서 이와 같은 문제점을 해결해주기 위해 나타난 것이, Spring Continaer이다.</p>\n<h2 id=\"lsp-리스코프-치환-원칙\" style=\"position:relative;\"><a href=\"#lsp-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99\" aria-label=\"lsp 리스코프 치환 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>LSP 리스코프 치환 원칙</h2>\n<ul>\n<li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.</li>\n<li>다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 뜻이다. 다형성을 지원하기 위한 원칙으로, 인터페이스를 구녛나 구현체를 믿고 사용하려면 해당 원칙이 필요하다.</li>\n</ul>\n<h2 id=\"isp-인터페이스-분리-원칙\" style=\"position:relative;\"><a href=\"#isp-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\" aria-label=\"isp 인터페이스 분리 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ISP 인터페이스 분리 원칙</h2>\n<ul>\n<li>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.</li>\n<li>예를 들어 자동차 인터페이스가 있다면 이를, 운전 인터페이스, 정비 인터페이스로 분리하는 것이 ISP의 예가 될 수 있다.</li>\n</ul>\n<h2 id=\"dip-의존-관계-역전\" style=\"position:relative;\"><a href=\"#dip-%EC%9D%98%EC%A1%B4-%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84\" aria-label=\"dip 의존 관계 역전 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DIP 의존 관계 역전</h2>\n<ul>\n<li>프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”</li>\n<li>역할(Role)에 의존하도록 코드를 구현해야한다.</li>\n</ul>\n<p>위에서 사용했던 예시도 마찬가지로 DIP도 위반하는 예시이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span>  <span class=\"token class-name\">MemberService</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// private MemberRepository memberRepository = new MemoryMemberRepository();</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">MemberRepository</span> memberRepository <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JdbcMemberRepository</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>보면 memberRepository는 결국 jdbcMemberRepository라는 구현체에 의존하고 있으므로, DIP에 위반이다.</p>","frontmatter":{"title":"다형성과 SOLID 5원칙","date":"August 25, 2022"}}},"pageContext":{"slug":"/Spring/다형성과SOLID5원칙/","previous":{"fields":{"slug":"/PS/DP/2631/post/"},"frontmatter":{"title":"백준 2631번 JAVA : 줄세우기"}},"next":{"fields":{"slug":"/Spring/IoC, DI And SOLID/"},"frontmatter":{"title":"SOLID를 적용하기 위한 해결책 IoC 그리고 DI"}}}}}