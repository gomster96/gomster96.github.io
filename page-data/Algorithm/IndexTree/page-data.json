{"componentChunkName":"component---src-templates-blog-post-js","path":"/Algorithm/IndexTree/","result":{"data":{"site":{"siteMetadata":{"title":"Gomster","author":"Gomster","siteUrl":"https://gomster96.github.io","comment":{"disqusShortName":"","utterances":"gomster96/gomster96.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"093aa84e-eee6-5568-8b3a-af73ae511a5f","excerpt":"인덱스 트리란 인덱스 트리는 포화 이진트리(모든 노드의 자식이 2인 이진트리)를 응용한 자료구조이다. 일반적으로 해당 두가지 연산을 M번 수행해야할 때 주로 사용한다. 구간 left, right(left <= right>) 이 주어졌을 때 Aleft + Aleft+1 + … + Aright-1+ Aright 의 합을 구해라 i번째 수 Ai를 V로 바꾸어라 이런 연산들이 여러번 수행할 때 인덱스 트리를 사용하면 모두 O(logN…","html":"<h1 id=\"인덱스-트리란\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%8A%B8%EB%A6%AC%EB%9E%80\" aria-label=\"인덱스 트리란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 트리란</h1>\n<p>인덱스 트리는 포화 이진트리(모든 노드의 자식이 2인 이진트리)를 응용한 자료구조이다. 일반적으로 해당 두가지 연산을 M번 수행해야할 때 주로 사용한다.</p>\n<ol>\n<li>구간 left, right(left &#x3C;= right>) 이 주어졌을 때 A[left] + A[left+1] + … + A[right-1]+ A[right] 의 합을 구해라</li>\n<li>i번째 수 A[i]를 V로 바꾸어라</li>\n</ol>\n<p>이런 연산들이 여러번 수행할 때 인덱스 트리를 사용하면 모두 O(logN)에 수행할 수 있다.</p>\n<h2 id=\"인덱스-트리의-특징\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%8A%B8%EB%A6%AC%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"인덱스 트리의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 트리의 특징</h2>\n<ul>\n<li>포화 이진트리 형태의 자료구조이다.</li>\n<li>리프노드 : 배열에 적혀있는 수 (N개)</li>\n<li>내부노드 : 왼쪽 자식과 오른쪽 자식의 합 (N-1개)</li>\n<li>리프노드의 개수가 N개 이상인 포화 이진트리는 높이가 최소 logN이다.</li>\n<li>\n<p>리프노드의 개수가 N개 보다 많아 비어있는 공간이 발생할 경우 구조에 지장이 가지 않도록 초기값을 설정한다. (주로 N의 두배만큼 설정하면 문제가 발생하지 않는다.)</p>\n<ul>\n<li>leaf는 2^n 꼴로만 만들 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"s값의-사용과-왼쪽-오른쪽-자식\" style=\"position:relative;\"><a href=\"#s%EA%B0%92%EC%9D%98-%EC%82%AC%EC%9A%A9%EA%B3%BC-%EC%99%BC%EC%AA%BD-%EC%98%A4%EB%A5%B8%EC%AA%BD-%EC%9E%90%EC%8B%9D\" aria-label=\"s값의 사용과 왼쪽 오른쪽 자식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>S값의 사용과 왼쪽 오른쪽 자식</h3>\n<ul>\n<li>리프 노드의 시작을 알리는 S값을 잘 사용하는 것이 중요하다.\nS값은 다음과 같이 구한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">int</span> <span class=\"token class-name\">S</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">S</span><span class=\"token operator\">&lt;</span> <span class=\"token class-name\">N</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">S</span> <span class=\"token operator\">*=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 2의 제곱수 중 N보다 큰 딱 그수를 S값으로 지정한다.</p>\n<p>현재 노드의 인덱스를 i라고 하면</p>\n<ul>\n<li>인덱스트리의 왼쪽 자식의 인덱스는 tree[i*2]이다.</li>\n<li>인덱스트리의 오른쪽 자식의 인덱스는 tree[i*2+1]이다.</li>\n</ul>\n<h1 id=\"인덱스-트리-구현\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84\" aria-label=\"인덱스 트리 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스 트리 구현</h1>\n<p>S값과 input들이 주어졌다고 가정하고 진행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">IndexTree</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tree<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> <span class=\"token class-name\">S</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> <span class=\"token class-name\">S</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> nInputs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\"><span class=\"token namespace\">this<span class=\"token punctuation\">.</span></span>S</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">S</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// S값의 2배 +1 만큼 선언해야 루트인 1부터 시작해서 리프노드까지 배열을 만들 수 있다.</span>\n        tree <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">S</span><span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token class-name\">N</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            tree<span class=\"token punctuation\">[</span><span class=\"token class-name\">S</span><span class=\"token operator\">+</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> nInputs<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 리프노드의 값을 넣어준다.</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token class-name\">S</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            tree<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> tree<span class=\"token punctuation\">[</span>i<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> tree<span class=\"token punctuation\">[</span>i<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 내부노드의 값을 넣어준다.</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// 원하고싶은 구간(queryLeft ~ queryRight)의 합을 찾는 함수이다.</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">long</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> right<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> node<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> queryLeft<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> queryRight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 현재노드의 구간합 left, right가 찾으려는 구간(queryRight, queryLeft)의 속하지 않으므로 패스</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">></span> queryRight <span class=\"token operator\">||</span> right <span class=\"token operator\">&lt;</span> queryLeft<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// 현재 노드의 구간합 left, right가 찾으려는 구간(queryRight, queryLeft)의 속하므로 return</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">>=</span> queryLeft <span class=\"token operator\">&amp;&amp;</span> right <span class=\"token operator\">&lt;=</span> queryRight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> tree<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 재귀적으로 자식들을 찾아가면서 value를 즉 구간합을 받아온다.</span>\n        <span class=\"token keyword\">long</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 왼쪽 자식이므로 node*2를 통해 왼쪽 자식의 node index를 접근할 수 있다.</span>\n        <span class=\"token keyword\">long</span> leftVal <span class=\"token operator\">=</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> node<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> queryLeft<span class=\"token punctuation\">,</span> queryRight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 오른쪽 자식이므로 node*2+1를 통해 왼쪽 자식의 node index를 접근할 수 있다.</span>\n        <span class=\"token keyword\">long</span> rightval <span class=\"token operator\">=</span> <span class=\"token function\">query</span><span class=\"token punctuation\">(</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> node<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> queryLeft<span class=\"token punctuation\">,</span> queryRight<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> leftVal <span class=\"token operator\">+</span> rightVal<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\">// update의 경우 루트에서부터 리프로 내려오면서 값의 변화만큼 변경해준다.</span>\n    <span class=\"token comment\">// 이때 변경해줄 diff를 구하기 위해 leaf의 값의 index는 S + [리프의 순서] -1 로 구할 수 있다.</span>\n    <span class=\"token comment\">// 변경할 리프가 3번째 수라면 해당 리프는 tree[S+3-1]을 통해 접근할 수 있다.</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">update</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> left<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> right<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> node<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> target<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> diff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// left, right 범위에 target이 속하지 않을경우 그냥 return 해준다.</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">></span> target <span class=\"token operator\">||</span> right <span class=\"token operator\">&lt;</span> target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">// left, right 범위에 target이 속할 경우 diff만큼 노드의 값을 변경해준다.</span>\n        tree<span class=\"token punctuation\">[</span>node<span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span> diff<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>left <span class=\"token operator\">!=</span> right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">long</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">+</span> right<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">update</span><span class=\"token punctuation\">(</span>left<span class=\"token punctuation\">,</span> mid<span class=\"token punctuation\">,</span> node<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">,</span> diff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">update</span><span class=\"token punctuation\">(</span>mid<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> right<span class=\"token punctuation\">,</span> node<span class=\"token operator\">*</span><span class=\"token number\">2</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> target<span class=\"token punctuation\">,</span> diff<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h1>\n<ol>\n<li>인덱스트리에서 가장 중요한 부분은 역시 S값이다. S값은 리프노드의 시작을 알림과 동시의 S-1을 통해 내부노드의 끝을 알 수 있다.</li>\n<li>query, update 를 할 때 재귀적으로 값을 구한다. 이중에서 가장 중요했던 부분은 찾을 값 또는 변경해줄 값이 left, right에 속하는지를 구분하는 것이 중요했다.</li>\n<li>인덱스트리의 node의 인덱스가 i라면 왼쪽자식의 인덱스는 i<em>2, 오른쪽자식의 인덱스는 i</em>2+1이다.</li>\n</ol>","frontmatter":{"title":"크루스칼 알고리즘 (Kruskal Algorithm)","date":"February 10, 2022"}}},"pageContext":{"slug":"/Algorithm/IndexTree/","previous":{"fields":{"slug":"/PS/MST/16398/"},"frontmatter":{"title":"백준 16398번 JAVA : 행성 연결"}},"next":null}}}