{"componentChunkName":"component---src-templates-blog-post-js","path":"/Algorithm/Dijkstra/","result":{"data":{"site":{"siteMetadata":{"title":"Gomster","author":"Gomster","siteUrl":"https://gomster96.github.io","comment":{"disqusShortName":"","utterances":"gomster96/gomster96.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"f0a9edf7-712b-5861-9ff7-6f46678927f1","excerpt":"다익스트라 알고리즘이란? 다익스트라 알고리즘은 V개의 정점과  E개의 간선을 가진 그래프 G에서 특정 출발 정점(S)에서 부터 다른 를 구하는 알고리즘이다. 다익스트라 알고리즘은 음이 아닌 가중 그래프(간선의 weight가 있는 그래프)에서의 단일 쌍, 단일 출발, 단일 도착 최단 경로문제일때 푼다. 다익스트라 알고리즘은 BFS를 기본으로 한다. 음수 가중치가 포함되어 있다면 사용할 수 없다. Priority Queue 또는 heap을 사용하여 O(ElogV…","html":"<!-- <p align=\"center\"><img src=\"1.png\" height=\"600px\" width=\"600px\"></p> -->\n<h1 id=\"다익스트라-알고리즘이란\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80\" aria-label=\"다익스트라 알고리즘이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다익스트라 알고리즘이란?</h1>\n<p>다익스트라 알고리즘은 V개의 정점과 <code class=\"language-text\">음수가 아닌</code> E개의 간선을 가진 그래프 G에서 특정 출발 정점(S)에서 부터 다른 <code class=\"language-text\">모든 정점까지의 최단 경로</code>를 구하는 알고리즘이다.</p>\n<ul>\n<li>다익스트라 알고리즘은 음이 아닌 가중 그래프(간선의 weight가 있는 그래프)에서의 단일 쌍, 단일 출발, 단일 도착 최단 경로문제일때 푼다.</li>\n<li>다익스트라 알고리즘은 BFS를 기본으로 한다.</li>\n<li>음수 가중치가 포함되어 있다면 사용할 수 없다.</li>\n<li>Priority Queue 또는 heap을 사용하여 <strong>O</strong>(<strong>E</strong>log<strong>V</strong>)의 시간복잡도를 가진다.</li>\n</ul>\n<h1 id=\"자바-코드\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%BD%94%EB%93%9C\" aria-label=\"자바 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바 코드</h1>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Main</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> v<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> dis<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">public</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> v<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> dis<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>v <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>dis <span class=\"token operator\">=</span> dis<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// V 정점의 개수</span>\n        <span class=\"token comment\">// E 간선의 개수일떄</span>\n        <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Node</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> graph <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">V</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// ArrayList의 배열로 각 정점에서 다른 정점으로 연결된 간선의 정보를 저장한다.</span>\n\n\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> distance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token class-name\">V</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 출발점에서 다른 정점으로 가는 최단거리를 저장하는 배열</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token class-name\">V</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            graph<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            distance<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token class-name\">Integer</span><span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">// 이후 그래프 관련 정보들을 저장한다.</span>\n\n        <span class=\"token comment\">// 현재 graph가 정리된 상태이며 start지점이 있다고 가정한다.</span>\n        <span class=\"token comment\">// ex) graph[3].get(1) == 3번 정점에서 1번정점으로 가는 거리를 뜻한다.</span>\n\n        <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 현재 start는 그냥 1이라고 칭하고 시작하겠다.</span>\n        <span class=\"token class-name\">PriorityQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Node</span><span class=\"token punctuation\">></span></span> pq <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PriorityQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e1<span class=\"token punctuation\">,</span> e2<span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> e1<span class=\"token punctuation\">.</span>dis <span class=\"token operator\">-</span> e2<span class=\"token punctuation\">.</span>dis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 각 정점에서 다른 정점으로의 거리 즉 dis 의 오름차순으로 pq를 정렬한다.</span>\n        distance<span class=\"token punctuation\">[</span>start<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 시작점에서 자기 자신으로 가는 최단거리는 0이므로 이렇게 초기화해준다.</span>\n        pq<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span>start<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 가장 먼저 시작할 start점 이므로 pq에 넣고 시작한다.</span>\n\n        <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>pq<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token class-name\">Node</span> now <span class=\"token operator\">=</span> pq<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> now<span class=\"token punctuation\">.</span>dis<span class=\"token punctuation\">)</span> <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// 현재 now.v 즉 now의 정점으로 까지 가는 거리가</span>\n            <span class=\"token comment\">// pq에서 저장된 정보인 now.v까지의 거리보다 짧을경우 변경할 사항이 없으므로 continue한다.</span>\n            <span class=\"token comment\">// 이때 &lt;= 는 하지 않는 이유는 거리가 같더라도 갈 수 있는 정점의 종류가 다를 경우도 있기 때문이다.</span>\n\n\n            <span class=\"token comment\">// 현재 distance의 변경사항이 있거나, 정점의 종류가 다를수도 있으므로 해당 Node를 기반으로 다시</span>\n            <span class=\"token comment\">// 갈 수 있는 graph를 확인한다.</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Node</span> next <span class=\"token operator\">:</span> graph<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>distance<span class=\"token punctuation\">[</span>next<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> next<span class=\"token punctuation\">.</span>dis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\">// 현재 distance배열에 저장된 next.v로 가는 최단거리가</span>\n                    <span class=\"token comment\">// now.v를 거치고 now.v에서 next.v까지의 거리를 합한 것보다 큰 경우</span>\n                    <span class=\"token comment\">// 최단거리를 업데이트 해준다.</span>\n                    distance<span class=\"token punctuation\">[</span>next<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> distance<span class=\"token punctuation\">[</span>now<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> next<span class=\"token punctuation\">.</span>dis<span class=\"token punctuation\">;</span>\n\n                    pq<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">,</span> distance<span class=\"token punctuation\">[</span>next<span class=\"token punctuation\">.</span>v<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\">// next.v로 가는 최단거리가 갱신되었기 때문에, 그 이후의 값들도 확인해야하기에</span>\n                    <span class=\"token comment\">// pq에 값을 넣어준다.</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\">// pq가 빌 때까지 계속하다보면 distance배열에 start에서 다른 정점으로 가는 최단거리가 저장되어있다.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 알고리즘의 시간복잡도가 <strong>O</strong>(<strong>E</strong>log<strong>V</strong>)인 이유는</p>\n<ol>\n<li>pq에서 가장 짧은 dis의 Node를 찾기가 최대 O(logE)가 된다.</li>\n<li>우선순위 큐에 추가하는 간선의 개수는 최대 O(E) 만 큼 걸린다. 이때 E즉 간선의 개수는 V^2 즉 정점의 제곱보다 작다</li>\n<li>O(ElogE) = O(ElogV^2) = O(2ElogV) = O(ElogV) 이다.</li>\n</ol>\n<h1 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h1>","frontmatter":{"title":"다익스트라 알고리즘 (Dijkstra Algorithm)","date":"January 27, 2022"}}},"pageContext":{"slug":"/Algorithm/Dijkstra/","previous":{"fields":{"slug":"/Algorithm/Kruskal/"},"frontmatter":{"title":"크루스칼 알고리즘 (Kruskal Algorithm)"}},"next":{"fields":{"slug":"/Algorithm/Bellman-Ford-Moore/"},"frontmatter":{"title":"벨만포드 알고리즘 (Bellman-Ford-Moore)"}}}}}