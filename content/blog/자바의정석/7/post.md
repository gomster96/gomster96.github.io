---
title: '자바의 정석 7장 객체지향 프로그래밍 2'
date: 2021-12-23 16:21:13
category: '자바의 정석'
draft: false
---

# 1. 클래스 간의 관계

## 1. 상속

상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.

- 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
- 코드를 공통으로 관리 할 수 있다.
- 상속받고자하는 클래스 이름을 extends 와 함께 사용하면 상속이 가능하다.
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손클래스의 멤버 개수는 부모 클래스보다 항상 같거나 많다.

→ 상속받은 자손 클래스는 부모 클래스의 모든 멤버를 상속받기때문에 Child클래스는 Parent 클래스의 멤버들을 모두 포함 할 수 있다.

### 단일 상속(single inheritance)

자바에서는 오직 하나의 클래스만을 상속받을 수 있는 단일 상속만을 허용한다.

→ 클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다는 장점이 있다.

### Object 클래스 - 모든 클래스의 부모

Object클래스는 모든 클래스의 상속계층도의 최상위에 있는 부모클래스이다.

→ 결국 마지막 최상위 조상은 Object 클래스이다.

→ toString(), equals와 같은 메서드를 정의하지 않고 사용할 수 있었던 이유는 이 메서드들이 모두 Object클래스에 정의된 것들이기 때문이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36528b0f-3513-492d-89bb-ced4e126a8b4/Untitled.png)

## 2. 포함

클래스 내부에서 새로운 클래스를 다시 만드는 것을 **포함 관계**를 맺는다고 한다.

```java
class Circle {
	Point c = new Point();
	int r;
}
```

## 클래스의 관계 결정하기

is - a 관계 : **상속**

- ~은 ~이다
- ex) 원(Circle)은 점(Point)이다

has - a 관계 : **포함**

- ~은 ~을 가지고 있다.
- ex) 원(Circle)은 점(Point)를 가지고 있다.

# 2. 오버라이딩(overriding)

부모클래스로부터 **상속받은 메서드**의 내용을 **변경하는 것**을 오버라이딩이라고 한다.

- 상속받은 메서드를 그대로 사용할 수 도 있지만, 자손 클래스 자신에 맞게 변경해야 할 경우 사용한다.

### 조건

오버라이딩은 메서드의 내용만을 작성하는 것이므로 메서드의 선언부는 조상의 것과 완전히 일치해야 한다.

- 이름이 같아야한다
- 매개변수가 같아야한다
- 반환타입이 같아야한다.
- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
- 인스턴스 메서드를 static메서드로 또는 그 반대로 변경 할 수 없다.

### super

상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super와 this를 사용하여 구별이 가능하다.

```java
super.변수 (부모의 변수)
this.변수 (자식 즉 자신의 변수)
```

변수 뿐만이 아니라 메서드 역시 마찬가지이다.

→ 조상 클래스의 메서드를 자손클래스에서 오버라이딩 한 경우 super를 사용하여 오버라이딩 전의 조상 클래스의 메서드를 호출할 수 있다.

### super() - 조상클래스의 생성자

super()는 조상 클래스의 생성자를 호출할 때 사용된다.

자식 클래스가 인스턴스를 생성하면, 조상의 멤버와 부모의 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다

→ **이를 위해서 부모의 생성자가 필요하다**, 만약 없을경우 컴파일러는 생성자의 첫줄에 **자동적으로**

**super();** 를 추가해준다.

→ **조상클래스의 멤버변수는 조상의 생성자**에 의해 초기화 되도록 해야한다.

# 3. Package와 import

패키지란 **클래스의 묶음**이다.

클래스가 물리적으로 하나의 클래스파일(.class)인 것처럼 패키지는 물리적으로 **하나의 디렉토리**이다.

### 선언

클래스나 인터페이스의 소스파일(.java)의 **맨 위에** 다음과 같이 적어주면 된다.

```java
package 패키지명;
```

- 클래스명과 구분하기 위해서 소문자로 하는것을 원칙으로한다
- 모든 클래스는 반드시 하나의 패키지에 포함되어야한다
- 맨위에 package가 적혀있지 않을 경우 기본적으로 제공하는 **이름없는 패키지**(unnamed package)에 포함된다.

### import문

import 문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스이름에서 패키지명은 생략 할 수 있다.

```java
import java.util.*;
import java.util.ArrayList;
// 이렇게 적을시 util패키지에서 쓸 수 있는 모든것은 패키지명을 생략해도 된다.
// 만약 import 를 하지 않았을 경우 java.util.ArrayList 이런식으로 패키지 명도 항상 추가해야한다.
```

### static import

static import 문을 사용하면 가지고올 클래스의 이름까지 생략할 수 있다.

```java
import static java.lang.System.out;
import static java.lang.Math.*;

class StaticImportEx1 {
	public static void main(String[] args){
		//System.out.println(Math.random()); 해당 라인을 아래처럼 바꿀 수 있다.
		out.println(random());
	}
}
```

# 4. 제어자 (modifier)

**접근제어자**

- public
- protected
- default
- private

**그 외**

- static
- final
- abstract
- 등

### static - 클래스의, 공통적인

static은 **클래스에 관계** 된 것이기 때문에 **인스턴스를 생성하지 않고도** 사용할 수 있다.

- static은 멤버변수, 메서드, 초기화 블럭에서 사용가능하다.

### final - 마지막의, 변경될 수 없는

변수에 사용되면 **값을 변경할 수 없는** 상수가 된다.

메서드에 사용되면 오버라이딩을 할 수 없게 된다.

클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.

ex) 대표적인 final class로 String과 Math가 있다.

### abstract - 추상의, 미완성의

abstract는 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.

abstract클래스는 자체로는 쓸모가 없지만, 다른 클래스가 **이 클래스를 상속받아서 일부의 원하는 메서드만 오버라이딩 해도 된다는 장점**이 있다. (interface와의 차이)

### 접근제어자 (private, default, protected, public)

접근제어자는 외부로부터 데이터를 보호하기 위해, 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서 사용된다.

private

- 같은 클래스 내에서만 접근이 가능하다

default

- 같은 패키지 내에서만 접근이 가능하다

protected

- 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다..

public

- 접근 제한이 전혀 없다

```java
public > protected > default > private
```

접근 제어자를 통해 객체지향의 개념인 캡슐화(encapsulation)을 할 수 있다.

- 멤버변수의 값을 읽는 메서드의 이름을 ‘get멤버변수이름’ (getter라고 부름)
- 멤버변수의 값을 변경하는 메서드의 이름을 ‘set멤버변수이름’ (setter라고 부름)

### 싱글톤 만들기

```java
class Singleton{
	private static Singleton s = new Singleton();
	// instance 가 미리 생성되어야 하므로 static으로 선언해야한다.
	private Singleton(){
		// 생성자 내용
	}
	public static Singleton getInstance(){
		return s;
	}
}
```

# 5. 다형성

# 6. 추상클래스

# 7. 인터페이스

# 8. 내부클래스
