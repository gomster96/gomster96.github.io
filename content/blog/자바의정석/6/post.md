---
title: '[자바의 정석] 6장 객체지향 프로그래밍 1'
date: 2021-12-23 16:26:13
category: '자바의 정석'
draft: false
---

# 객체지향언어

### 기본 이론

"실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다."

### 객체지향언어 특징

1. 코드의 재사용성이 높다

- 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.

2. 코드의 관리가 용이하다

- 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.

3. 신뢰성이 높은 프로그래밍을 가능하게 한다

- 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

# 클래스와 객체

## 정의

클래스 : 클래스란 객체를 정의해 놓은 것이다. 객체를 생성하는데 사용된다.

또다른 클래스의 정의

- 데이터와 함수의 결합
- 사용자 정의 타입

객체 : 실제로 존재하는 것, 사물 또는 개념. 객체가 가지고 있는 기능과 속성에 따라 다름

### 객체와 인스턴스

클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)라고 한다. 또한 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스 라고 부른다.

아래 예시처럼 new 명령어를 통해 인스턴스를 만들 수 있다.

```java
클래스명 변수명 = new 클래스명();
```

### 객체의 구성요소

#### 속성(property)

- 멤버변수(member variable)
- 특성(attribute)
- 필드(field)
- 상태(state)

#### 기능(function)

- 메서드(method)
- 함수(function)
- 행위(behavior)

# 메서드와 변수

## 변수

```java
class Variable{
	int iv; // 인스턴스 변수
    static int cv; // 클래스변수
    void method(){
    	int lv = 0; // 지역변수
    }
}
```

### 1. 인스턴스 변수

클래스 영역에 선언되며 클래스의 인스턴스를 생성할 때 만들어진다. 인스턴스는 독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있다.

- 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언한다.

### 2. 클래스 변수

인스턴스 변수 앞에 static을 붙이면 된다.
클래스변수는 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 된다.

- 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 사용한다.

```java
className.classVariable
//인스턴스 변수와 구별을 주기 위해 일반적으로 다음과 같은 모습으로 사용한다.
```

### 3. 지역변수

메서드 내에 선언되며 사용된다. 메서드가 종료되면 소멸되어 사용할 수 없게 된다.
마찬가지로 for문 이나 while문 if문등 블럭 내에 선언된 지역변수는, 지역변수가 선언된 블럭{} 내에서만 사용 가능하며 블럭을 벗어나면 소멸된다.

## 메서드

### 메서드 사용이유

1. 높은 재사용성
2. 중복된 코드의 제거
3. 프로젝트의 구조화

### 메서드의 선언

c에서의 일반적인 함수와 선언방법 및 사용방법이 동일하다.

## JVM의 메모리구조

1. 메서드 영역

- JVM은 해당 클래스의 클래스파일(\*.class)을 읽어서 클래스에 대한 정보를 이곳에 저장한다.
- 클래스변수(class variable)도 이 영역과 함께 생성된다.

2. 힙(heap)

- 인스턴스가 생성되는 공간
- 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다.
- 인스턴스 변수(instance variable)들이 생성되는 공간이다.

3. 호출스택(call stack)

- 메서드의 작업에 필요한 메모리 공간을 제공한다.
- 호출 스택에 호출된 메서드를 위한 메모리가 할당되며, 공간은 메서드가 작업을 수행하는 동안 필요한 지역변수 등과 연산의 중간결과등을 저장할때 사용한다.
- 메서드가 작업을 마치면, 할당되었던 메모리공간은 반환되어 비워진다.

```
- 메서드가 호출되면 수행에 필요한 만큼에 멤모리 할당
- 메서드가 수행을 마치면 사용했던 메모리를 반환하고 스택에서 제거
- 호출 스택에 제일 위에 있는 메서드가 현재 실행 중 메서드
- 아래에 있는 메서드가 바로 위에 메서드를 호출한 메서드
```

## 기본형 매개변수 vs 참조형 매개변수

기본형 매개변수 (1, 10, 'c' 등)

- 값을 보낸 것
- 값만을 보낸 거기 때문에 보낸 값을 읽기만 가능하다

참조형 매개변수 (객체, 배열 등)

- 주소를 보낸것
- 따라서 해당 주소의 직접 접근이 가능하기 때문에 값을 수정 가능하다.

## 정리

#### 1. 클래스를 설계할 때, 멤버 변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.

#### 2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.

#### 3. 클래스 메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.

#### 4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

```java
class example{
    	// 인스턴스 메서드
	long a, b;
	long add() { return this.a+this.b};
    	// static메서드
	static long add(long a, long b){return a+b; }
}
```

# 오버로딩

한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버로딩' or 오버로딩(overloading) 이라고 한다.

#### 오버로딩의 조건

1. 메서드 이름이 같아야한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.
3. 반환타입은 오버로딩을 구현하는데 아무런 영향을 끼치지 않는다.

```java
class example{
	int add(int a, int b) { return a+b;}
    long add(long a, long b) {return a+b; }
}
```

### 가변인자 사용

```java
class example{
	int test(int a, String... str){
    	// str은 배열로서 사용할 수 있게된다.
    }
}
test(1, "a", "b", "c") // test함수에서 str은 [a][b][c] 가 된다.
test(1, "a", "b") // test함수에서 str은 [a][b] 가 된다.
```

즉 가변인자는 추가적인 parameter들을 array로 변환시켜주는 것이다.

# 생성자

생성자는 인스턴스가 생성될 때 호출되는 **'인스턴스 초기화 메서드'** 이다.

#### 조건

```java
1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다.
```

- **new**가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.
- 생성자는 단순히 **인스턴스 변수들을 초기화**하는 것이다.

### this()

- 생성자의 이름으로 클래스이름 대신 this사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다
